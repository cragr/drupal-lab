<?php

namespace Drupal\Tests\Traits\Core;

use Drupal\Core\Logger\RfcLogLevel;
use PHPUnit\Framework\ExpectationFailedException;

/**
 * Add the ability to set test expectations for the presence or absence of log messages.
 */
trait LoggingTrait {

  /**
   *  The messages that this test expects to be logged.
   */
  protected array $expectedLogs = [];

  /**
   *  The messages that this test expects will not be logged.
   */
  protected array $disallowedLogs = [];

  /**
   *  The messages that this test allows but does not expect.
   */
  protected array $allowedLogs = [];

  /**
   * Setup an expectation that a test will generate a log message.
   *
   * If a matching log message is not generated, the test will fail.
   *
   * @param int $severity
   *   The log severity as defined in Drupal\Core\Logger\RfcLogLevel.
   * @param string $severity
   *   The logger channel.
   * @param string $message
   *   (optional) Text that the log message must contain.
   */
  protected function expectLog($severity, $channel, $message = '') {
    $count = 1 + ($this->expectedLogs[$severity][$channel][$message] ?? 0);
    $this->expectedLogs[$severity][$channel][$message] = $count;
  }

  /**
   * Setup an expectation that a test will not generate a log message.
   *
   * If a matching log message is generated, the test will fail. Log
   * messages of the specified severity or greater will trigger a test
   * to fail as soon as they are received.
   *
   * Log messages that are set up as expected (by ::expectLog()) or
   * are set up as allowed (by ::allowLog()) are exempt and will not
   * trigger failure.
   *
   * @param int $severity
   *   (optional) The log severity as defined in Drupal\Core\Logger\RfcLogLevel.
   * @param string $severity
   *   (optional) The logger channel.
   * @param string $message
   *   (optional) Text that the log message must contain.
   */
  protected function expectNoLog($severity = '', $channel = '', $message = '') {
    $this->disallowedLogs[$channel][$message] = $severity;
  }

  /**
   * Define a certain kind of log message as allowed.
   *
   * If a generated log message matches the specified paramaters, then
   * it will not cause a test to fail even if would otherwise have been
   * disallowed (by ::expectNoLog()).
   *
   * Typically expectNoLog() is used to define a broad class of
   * unacceptable log messages, e.g. 'fail all warnings and above', and
   * then allowLog() is used to define an narrower exception to that,
   * e.g. 'except allow warnings from the user channel'.
   *
   * @param int $severity
   *   The log severity as defined in Drupal\Core\Logger\RfcLogLevel.
   * @param string $severity
   *   The logger channel.
   * @param string $message
   *   (optional) Text that the log message must contain.
   */
  protected function allowLog($severity, $channel, $message = '') {
    $this->allowedLogs[$channel][$message] = $severity;
  }

  /**
   * Process a log message received by the test.
   *
   * If the log message is expected, it is tracked so that
   * expectations can be verified at the end of the test. If the
   * log message is not allowed, the test is failed immediately.
   *
   * @param int $severity
   *   The log severity as defined in Drupal\Core\Logger\RfcLogLevel.
   * @param string $severity
   *   The logger channel.
   * @param string $message
   *   The log message.
   */
  protected function handleLog($severity, $channel, $message) {
    $isExpected = $this->handleLogExpectations($severity, $channel, $message) || $this->handleLogExpectations($severity, $channel, '');
    if ($isExpected) {
      return;
    }

    $isAllowed = $this->isLogAllowed($this->allowedLogs, TRUE, $severity, $channel, $message);
    if (!$isAllowed) {
      $isDisallowed = $this->isLogAllowed($this->disallowedLogs, FALSE, $severity, $channel, $message);
      if ($isDisallowed) {
        throw new ExpectationFailedException("Disallowed log message received: $severity $channel $message");
      }
    }
  }

  /**
   * Process a log message received by the test in the context of expectations.
   *
   * If the log message matches an expected type of log message,
   * then the count of outstanding expectations of that type is reduced.
   *
   * @param int $severity
   *   The log severity as defined in Drupal\Core\Logger\RfcLogLevel.
   * @param string $severity
   *   The logger channel.
   * @param string $message
   *   The log message.
   */
  protected function handleLogExpectations($severity, $channel, $message) {
    if (isset($this->expectedLogs[$severity][$channel])) {
      foreach ($this->expectedLogs[$severity][$channel] as $expectedMessage) {
        if (strpos($message, $expectedMessage) !== FALSE) {
          $this->expectedLogs[$severity][$channel][$expectedMessage] = $this->expectedLogs[$severity][$channel][$expectedMessage] - 1;
          if ($this->expectedLogs[$severity][$channel][$expectedMessage] === 0) {
              unset($this->expectedLogs[$severity][$channel][$expectedMessage]);
          }
          return TRUE;
        }
      }
    }
    return FALSE;
  }

  /**
   * Determine if a log message is allowed.
   *
   * A received log essage is compared against a set of rules set up
   * earlier to see if there is a match. A rule matches a log message if:
   * - it has the same channel specified or no channel specified
   * - it's message is contained in the actual log message
   * - it's severity is more or less than the log severity, depending on $allowed
   *
   * @param array $rules
   *   A set of log rules set up earlier.
   * @param bool $allowed
   *   Whether to match severity greater or lesser than the rule.
   * @param int $severity
   *   The log severity as defined in Drupal\Core\Logger\RfcLogLevel.
   * @param string $severity
   *   The logger channel.
   * @param string $message
   *   The log message.
   */
  protected function isLogAllowed(array $rules, $allowed, $severity, $channel, $message) {
    $channels = [$channel, ''];
    for ($channel in $channels) {
      $channelRules = $rules[$channel];
      foreach($channelRules as $ruleMessage => $ruleSeverity) {
        if (strpos($message, $ruleMessage) !== FALSE || $ruleMessage === '') {
          if (($allowed && $ruleSeverity >= $severity) ||
          (!$allowed && $ruleSeverity <= $severity)){
            return TRUE;
          }
        }
      }
    }
    return FALSE;
  }

  /**
   * Assert that no logs were expected that have not been received..
   *
   **/
  protected function assertLogExpectationsMet() {
    $this->assertEmpty($this->expectedLogs);
  }


}

