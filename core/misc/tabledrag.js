/**
* DO NOT EDIT THIS FILE.
* See the following change record for more information,
* https://www.drupal.org/node/2815083
* @preserve
**/

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

(function ($, Drupal, drupalSettings) {
  var showWeight = JSON.parse(localStorage.getItem('Drupal.tableDrag.showWeight'));
  Drupal.behaviors.tableDrag = {
    attach: function attach(context, settings) {
      function initTableDrag(table, base) {
        if (table.length) {
          Drupal.TableDrag.instances[base] = new Drupal.TableDrag(table[0], settings.tableDrag[base]);
        }
      }

      Object.keys(settings.tableDrag || {}).forEach(function (base) {
        initTableDrag($(context).find("#".concat(base)).once('tabledrag'), base);
      });
    }
  };

  Drupal.TableDrag = function () {
    function _class(table, tableSettings) {
      var _this = this;

      _classCallCheck(this, _class);

      this.table = table;
      this.table.setAttribute('data-drupal-tabledrag-table', '');
      this.tableSettings = tableSettings;
      this.dragObject = null;
      this.rowObject = null;
      this.oldRowElement = null;
      this.oldY = null;
      this.changed = false;
      this.maxDepth = 0;
      this.rtl = window.getComputedStyle(this.table).getPropertyValue('direction') === 'rtl' ? -1 : 1;
      this.striping = this.table.getAttribute('data-striping') === '1';
      this.scrollSettings = {
        amount: 4,
        interval: 50,
        trigger: 70
      };
      this.scrollInterval = null;
      this.scrollY = 0;
      this.windowHeight = 0;
      this.toggleWeightButton = null;
      this.indentEnabled = false;
      Object.keys(tableSettings || {}).forEach(function (group) {
        Object.keys(tableSettings[group] || {}).forEach(function (n) {
          if (tableSettings[group][n].relationship === 'parent') {
            _this.indentEnabled = true;
          }

          if (tableSettings[group][n].limit > 0) {
            _this.maxDepth = tableSettings[group][n].limit;
          }
        });
      });

      if (this.indentEnabled) {
        this.indentCount = 1;
        var indent = this.constructor.stringToElement(Drupal.theme('tableDragIndentation'));
        var testRow = document.createElement('tr');
        this.table.appendChild(testRow);
        var testCell = document.createElement('td');
        testRow.appendChild(testCell);
        testCell.appendChild(indent);
        testCell.appendChild(indent.cloneNode(true));
        var indentations = testCell.querySelectorAll('.js-indentation');
        this.indentAmount = indentations[1].getBoundingClientRect().x - indentations[0].getBoundingClientRect().x;
        testRow.parentNode.removeChild(testRow);
      }

      this.table.querySelectorAll(':scope > tr.draggable, :scope > tbody > tr.draggable').forEach(function (row) {
        _this.makeDraggable(row);
      });
      var toggleWeightWrapper = this.constructor.stringToElement(Drupal.theme('tableDragToggle'));
      this.toggleWeightButton = toggleWeightWrapper.querySelector('[data-drupal-selector="tabledrag-toggle-weight"]');
      $(this.toggleWeightButton).on('click', function (e) {
        e.preventDefault();

        _this.toggleColumns();
      });
      this.table.parentNode.insertBefore(toggleWeightWrapper, this.table);
      this.initColumns();
      $(document).on('touchmove', function (event) {
        return _this.dragRow(event.originalEvent.touches[0]);
      });
      $(document).on('touchend', function (event) {
        return _this.dropRow(event.originalEvent.touches[0]);
      });
      $(document).on('mousemove pointermove', function (event) {
        return _this.dragRow(event);
      });
      $(document).on('mouseup pointerup', function (event) {
        return _this.dropRow(event);
      });
      $(window).on('storage', function (e) {
        if (e.originalEvent.key === 'Drupal.tableDrag.showWeight') {
          showWeight = JSON.parse(e.originalEvent.newValue);

          _this.displayColumns(showWeight);
        }
      });
    }

    _createClass(_class, [{
      key: "initColumns",
      value: function initColumns() {
        var _this2 = this;

        var hidden;
        var cell;
        Object.keys(this.tableSettings || {}).forEach(function (group) {
          Object.keys(_this2.tableSettings[group]).some(function (tableSetting) {
            var field = _this2.table.querySelector(".".concat(_this2.tableSettings[group][tableSetting].target));

            if (field && _this2.tableSettings[group][tableSetting].hidden) {
              hidden = _this2.tableSettings[group][tableSetting].hidden;
              cell = field.closest('td');
              return true;
            }

            return false;
          });

          if (hidden && cell) {
            var columnIndex = Array.prototype.indexOf.call(cell.parentNode.querySelectorAll(':scope > td'), cell) + 1;

            _this2.table.querySelectorAll(':scope > thead > tr, :scope > tbody > tr, :scope > tr').forEach(function (row) {
              _this2.constructor.addColspanClass(row, columnIndex);
            });
          }
        });
        this.displayColumns(showWeight);
      }
    }, {
      key: "displayColumns",
      value: function displayColumns(displayWeight) {
        if (displayWeight) {
          this.constructor.showColumns();
        } else {
            this.constructor.hideColumns();
          }

        this.toggleWeightButton.innerHTML = Drupal.theme('toggleButtonContent', displayWeight);
        $('table').findOnce('tabledrag').trigger('columnschange', !!displayWeight);
      }
    }, {
      key: "toggleColumns",
      value: function toggleColumns() {
        showWeight = !showWeight;
        this.displayColumns(showWeight);

        if (showWeight) {
          localStorage.setItem('Drupal.tableDrag.showWeight', showWeight);
        } else {
          localStorage.removeItem('Drupal.tableDrag.showWeight');
        }
      }
    }, {
      key: "rowSettings",
      value: function rowSettings(group, row) {
        var field = row.querySelector(".".concat(group));
        var tableSettingsGroup = this.tableSettings[group];
        return Object.keys(tableSettingsGroup).map(function (delta) {
          var targetClass = tableSettingsGroup[delta].target;
          var rowSettings;

          if (field.matches(".".concat(targetClass))) {
            rowSettings = {};
            Object.keys(tableSettingsGroup[delta]).forEach(function (n) {
              rowSettings[n] = tableSettingsGroup[delta][n];
            });
          }

          return rowSettings;
        }).filter(function (rowSetting) {
          return rowSetting;
        })[0];
      }
    }, {
      key: "makeDraggable",
      value: function makeDraggable(row) {
        var _this3 = this;

        row.querySelectorAll('td:first-of-type a').forEach(function (link) {
          link.classList.add('menu-item__link');
        });
        var handle = this.constructor.stringToElement(Drupal.theme('tableDragHandle'));
        var indentations = row.querySelectorAll('td:first-of-type .js-indentation');
        var indentationLast = indentations.length > 0 ? indentations[indentations.length - 1] : null;

        if (indentationLast) {
          indentationLast.after(handle);
          this.indentCount = Math.max(indentations.length, this.indentCount);
        } else {
          row.querySelector('td').prepend(handle);
        }

        $(handle).on('mousedown touchstart pointerdown', function (event) {
          event.preventDefault();
          var eventToSend = event.originalEvent.type === 'touchstart' ? event.originalEvent.touches[0] : event;

          _this3.dragStart(eventToSend, row);
        });
        $(handle).on('click', function (e) {
          e.preventDefault();
        });
        $(handle).on('focus', function () {
          _this3.safeBlur = true;
        });
        $(handle).on('blur', function (event) {
          if (_this3.rowObject && _this3.safeBlur) {
            _this3.dropRow(event);
          }
        });
        $(handle).on('keydown', function (event) {
          if (event.keyCode !== 9 && !_this3.rowObject) {
            _this3.rowObject = _this3.row(row, 'keyboard', _this3.indentEnabled, _this3.maxDepth, true);
          }

          var keyChange = false;
          var groupHeight;

          switch (event.keyCode) {
            case 37:
              keyChange = true;

              _this3.rowObject.indent(-1 * _this3.rtl);

              break;

            case 38:
              {
                var previousRow = _this3.constructor.previous(_this3.rowObject.element, 'tr');

                while (previousRow && _this3.constructor.isHidden(previousRow)) {
                  previousRow = _this3.constructor.previous(previousRow, 'tr');
                }

                if (previousRow) {
                  _this3.safeBlur = false;
                  _this3.rowObject.direction = 'up';
                  keyChange = true;

                  if (row.matches('.tabledrag-root')) {
                    groupHeight = 0;

                    while (previousRow && previousRow.querySelectorAll('.js-indentation').length) {
                      previousRow = _this3.constructor.previous(previousRow, 'tr');
                      groupHeight += _this3.constructor.isHidden(previousRow) ? 0 : previousRow.offsetHeight;
                    }

                    if (previousRow) {
                      _this3.rowObject.swap('beforebegin', previousRow);

                      window.scrollBy(0, -groupHeight);
                    }
                  } else if (_this3.table.tBodies[0].rows[0] !== previousRow || previousRow.matches('.draggable')) {
                    _this3.rowObject.swap('beforebegin', previousRow);

                    _this3.rowObject.interval = null;

                    _this3.rowObject.indent(0);

                    window.scrollBy(0, -parseInt(row.offsetHeight, 10));
                  }

                  handle.focus();
                }

                break;
              }

            case 39:
              keyChange = true;

              _this3.rowObject.indent(_this3.rtl);

              break;

            case 40:
              {
                var nextRow = _this3.constructor.next(_this3.rowObject.group[_this3.rowObject.group.length - 1], 'tr');

                while (nextRow && _this3.constructor.isHidden(nextRow)) {
                  nextRow = _this3.constructor.next(nextRow);
                }

                if (nextRow) {
                  _this3.safeBlur = false;
                  _this3.rowObject.direction = 'down';
                  keyChange = true;

                  if (row.matches('.tabledrag-root')) {
                    groupHeight = 0;

                    var nextGroup = _this3.row(nextRow, 'keyboard', _this3.indentEnabled, _this3.maxDepth, false);

                    if (nextGroup) {
                      nextGroup.group.forEach(function (groupRow) {
                        groupHeight += _this3.constructor.isHidden(groupRow) ? 0 : _this3.offsetHeight;
                      });
                      var nextGroupRow = nextGroup.group[nextGroup.group.length - 1];

                      _this3.rowObject.swap('afterend', nextGroupRow);

                      window.scrollBy(0, parseInt(groupHeight, 10));
                    }
                  } else {
                    _this3.rowObject.swap('afterend', nextRow);

                    _this3.rowObject.interval = null;

                    _this3.rowObject.indent(0);

                    window.scrollBy(0, parseInt(row.offsetHeight, 10));
                  }

                  handle.focus();
                }

                break;
              }
          }

          if (_this3.rowObject && _this3.rowObject.changed === true) {
            row.classList.add('drag');

            if (_this3.oldRowElement) {
              _this3.oldRowElement.classList.remove('drag-previous');
            }

            _this3.oldRowElement = row;

            if (_this3.striping === true) {
              _this3.restripeTable();
            }

            _this3.onDrag();
          }

          if (keyChange) {
            return false;
          }
        });
      }
    }, {
      key: "dragStart",
      value: function dragStart(event, row) {
        this.dragObject = {};
        this.dragObject.initOffset = this.getPointerOffset(row, event);
        this.dragObject.initPointerCoords = this.constructor.pointerCoords(event);

        if (this.indentEnabled) {
          this.dragObject.indentPointerPos = this.dragObject.initPointerCoords;
        }

        if (this.rowObject) {
          var handle = this.rowObject.element.querySelector('a.tabledrag-handle');

          if (handle) {
            handle.blur();
          }
        }

        this.rowObject = this.row(row, 'pointer', this.indentEnabled, this.maxDepth, true);
        this.table.topY = this.table.getBoundingClientRect().top + this.table.ownerDocument.defaultView.pageYOffset;
        this.table.bottomY = this.table.topY + this.table.offsetHeight;
        row.classList.add('drag');
        document.body.classList.add('drag');

        if (this.oldRowElement) {
          this.oldRowElement.classList.remove('drag-previous');
        }

        this.oldY = this.constructor.pointerCoords(event).y;
      }
    }, {
      key: "dragRow",
      value: function dragRow(event) {
        if (this.dragObject) {
          this.currentPointerCoords = this.constructor.pointerCoords(event);
          var y = this.currentPointerCoords.y - this.dragObject.initOffset.y;
          var x = this.currentPointerCoords.x - this.dragObject.initOffset.x;

          if (y !== this.oldY) {
            this.rowObject.direction = y > this.oldY ? 'down' : 'up';
            this.oldY = y;
            var scrollAmount = this.checkScroll(this.currentPointerCoords.y);
            clearInterval(this.scrollInterval);

            if (scrollAmount > 0 && this.rowObject.direction === 'down' || scrollAmount < 0 && this.rowObject.direction === 'up') {
              this.setScroll(scrollAmount);
            }

            var dropTargetRow = this.findDropTargetRow(x, y);

            if (dropTargetRow) {
              if (this.rowObject.direction === 'down') {
                this.rowObject.swap('afterend', dropTargetRow);
              } else {
                this.rowObject.swap('beforebegin', dropTargetRow);
              }

              if (this.striping === true) {
                this.restripeTable();
              }
            }
          }

          if (this.indentEnabled) {
            var xDiff = this.currentPointerCoords.x - this.dragObject.indentPointerPos.x;
            var indentDiff = Math.round(xDiff / this.indentAmount);
            var indentChange = this.rowObject.indent(indentDiff);
            this.dragObject.indentPointerPos.x += this.indentAmount * indentChange * this.rtl;
            this.indentCount = Math.max(this.indentCount, this.rowObject.indents);
          }

          return false;
        }
      }
    }, {
      key: "dropRow",
      value: function dropRow(event) {
        var _this4 = this;

        if (this.rowObject !== null) {
          if (this.rowObject.changed === true) {
            this.updateFields(this.rowObject.element);
            Object.keys(this.tableSettings || {}).forEach(function (group) {
              var rowSettings = _this4.rowSettings(group, _this4.rowObject.element);

              if (rowSettings.relationship === 'group') {
                Object.keys(_this4.rowObject.children || {}).forEach(function (n) {
                  _this4.updateField(_this4.rowObject.children[n], group);
                });
              }
            });
            this.rowObject.markChanged();

            if (this.changed === false) {
              var tableDragChangedWarning = this.constructor.stringToElement(Drupal.theme('tableDragChangedWarning'));

              if (tableDragChangedWarning) {
                this.table.parentNode.insertBefore(tableDragChangedWarning, this.table);
              }

              this.changed = true;
            }
          }

          if (this.indentEnabled) {
            this.rowObject.removeIndentClasses();
          }

          if (this.oldRowElement) {
            this.oldRowElement.classList.remove('drag-previous');
          }

          this.rowObject.element.classList.remove('drag');
          this.rowObject.element.classList.add('drag-previous');
          this.oldRowElement = this.rowObject.element;
          this.onDrop();
          this.rowObject = null;
        }

        if (this.dragObject !== null) {
          this.dragObject = null;
          document.body.classList.remove('drag');
          clearInterval(this.scrollInterval);
        }
      }
    }, {
      key: "getPointerOffset",
      value: function getPointerOffset(row, event) {
        var rowRect = row.getBoundingClientRect();
        var pointerPos = this.constructor.pointerCoords(event);
        return {
          x: pointerPos.x - (rowRect.x + row.ownerDocument.defaultView.pageXOffset),
          y: pointerPos.y - (rowRect.y + row.ownerDocument.defaultView.pageYOffset)
        };
      }
    }, {
      key: "findDropTargetRow",
      value: function findDropTargetRow(x, y) {
        var _this5 = this;

        var rows = [].slice.call(this.table.tBodies[0].rows).filter(function (row) {
          return !_this5.constructor.isHidden(row);
        });

        var _loop = function _loop(n) {
          var row = rows[n];
          var rowY = row.getBoundingClientRect().top + row.ownerDocument.defaultView.pageYOffset;
          var rowHeight = void 0;

          if (row.offsetHeight === 0) {
            rowHeight = parseInt(row.firstChild.offsetHeight, 10) / 2;
          } else {
              rowHeight = parseInt(row.offsetHeight, 10) / 2;
            }

          if (y > rowY - rowHeight && y < rowY + rowHeight) {
            if (_this5.indentEnabled) {
              if (Object.keys(_this5.rowObject.group).some(function (o) {
                return _this5.rowObject.group[o] === row;
              })) {
                return {
                  v: null
                };
              }
            } else if (row === _this5.rowObject.element) {
                return {
                  v: null
                };
              }

            if (!_this5.rowObject.isValidSwap(row)) {
              return {
                v: null
              };
            }

            while (_this5.constructor.isHidden(row) && _this5.constructor.isHidden(_this5.constructor.previous(row, 'tr'))) {
              row = _this5.constructor.previous(row, 'tr:first-of-type');
            }

            return {
              v: row
            };
          }
        };

        for (var n = 0; n < rows.length; n++) {
          var _ret = _loop(n);

          if (_typeof(_ret) === "object") return _ret.v;
        }

        return null;
      }
    }, {
      key: "updateFields",
      value: function updateFields(changedRow) {
        var _this6 = this;

        Object.keys(this.tableSettings || {}).forEach(function (group) {
          _this6.updateField(changedRow, group);
        });
      }
    }, {
      key: "updateField",
      value: function updateField(changedRow, group) {
        var rowSettings = this.rowSettings(group, changedRow);
        var sourceRow;
        var previousRow;
        var useSibling;

        if (rowSettings.relationship === 'self' || rowSettings.relationship === 'group') {
          sourceRow = changedRow;
        } else if (rowSettings.relationship === 'sibling') {
            previousRow = this.constructor.previous(changedRow, 'tr:first-of-type');
            var nextRow = this.constructor.next(changedRow, 'tr:first-of-type');
            sourceRow = changedRow;

            if (previousRow && previousRow.matches('.draggable') && previousRow.querySelectorAll(".".concat(group)).length) {
              if (this.indentEnabled) {
                if (previousRow.querySelectorAll('.js-indentations').length === changedRow.querySelectorAll('.js-indentations').length) {
                  sourceRow = previousRow;
                }
              } else {
                sourceRow = previousRow;
              }
            } else if (nextRow && nextRow.matches('.draggable') && nextRow.querySelectorAll(".".concat(group)).length) {
              if (this.indentEnabled) {
                if (nextRow.querySelectorAll('.js-indentations').length === changedRow.querySelectorAll('.js-indentations').length) {
                  sourceRow = nextRow;
                }
              } else {
                sourceRow = nextRow;
              }
            }
          } else if (rowSettings.relationship === 'parent') {
              previousRow = this.constructor.previous(changedRow, 'tr');

              while (previousRow && previousRow.querySelectorAll('.js-indentation').length >= this.rowObject.indents) {
                previousRow = this.constructor.previous(previousRow, 'tr');
              }

              if (previousRow) {
                sourceRow = previousRow;
              } else {
                  sourceRow = this.table.querySelector('tr.draggable');

                  if (sourceRow === this.rowObject.element && this.table.querySelectorAll('tr.draggable').length > 1) {
                    sourceRow = this.constructor.next(this.rowObject.group[this.rowObject.group.length - 1], 'tr.draggable');
                  }

                  useSibling = true;
                }
            }

        this.constructor.copyDragClasses(sourceRow, changedRow, group);
        rowSettings = this.rowSettings(group, changedRow);

        if (useSibling) {
          rowSettings.relationship = 'sibling';
          rowSettings.source = rowSettings.target;
        }

        var targetClass = ".".concat(rowSettings.target);
        var targetElement = changedRow.querySelector(targetClass);

        if (targetElement) {
          var sourceClass = ".".concat(rowSettings.source);
          var sourceElement = sourceRow.querySelector(sourceClass);

          switch (rowSettings.action) {
            case 'depth':
              targetElement.value = sourceElement.closest('tr').querySelectorAll('.js-indentation').length;
              break;

            case 'match':
              targetElement.value = sourceElement.value;
              break;

            case 'order':
              {
                var siblings = this.rowObject.findSiblings(rowSettings);

                if (targetElement.matches('select')) {
                  var values = [];
                  targetElement.querySelectorAll('option').forEach(function (option) {
                    values.push(option.value);
                  });
                  var maxVal = values[values.length - 1];
                  siblings.forEach(function (sibling) {
                    sibling.querySelectorAll(targetClass).forEach(function (target) {
                      if (values.length > 0) {
                        target.value = values.shift();
                      } else {
                        target.value = maxVal;
                      }
                    });
                  });
                } else {
                  var weight = parseInt(siblings[0].querySelector(targetClass).value, 10) || 0;
                  siblings.forEach(function (sibling) {
                    sibling.querySelectorAll(targetClass).forEach(function (input) {
                      input.value = weight;
                      weight += 1;
                    });
                  });
                }

                break;
              }
          }
        }
      }
    }, {
      key: "checkScroll",
      value: function checkScroll(cursorY) {
        var de = document.documentElement;
        var b = document.body;
        var windowHeight = window.innerHeight || (de.clientHeight && de.clientWidth !== 0 ? de.clientHeight : b.offsetHeight);
        this.windowHeight = windowHeight;
        var scrollY;

        if (document.all) {
          scrollY = !de.scrollTop ? b.scrollTop : de.scrollTop;
        } else {
          scrollY = window.pageYOffset ? window.pageYOffset : window.scrollY;
        }

        this.scrollY = scrollY;
        var trigger = this.scrollSettings.trigger;
        var delta = 0;

        if (cursorY - scrollY > windowHeight - trigger) {
          delta = trigger / (windowHeight + scrollY - cursorY);
          delta = delta > 0 && delta < trigger ? delta : trigger;
          return delta * this.scrollSettings.amount;
        }

        if (cursorY - scrollY < trigger) {
          delta = trigger / (cursorY - scrollY);
          delta = delta > 0 && delta < trigger ? delta : trigger;
          return -delta * this.scrollSettings.amount;
        }
      }
    }, {
      key: "setScroll",
      value: function setScroll(scrollAmount) {
        var _this7 = this;

        this.scrollInterval = setInterval(function () {
          _this7.checkScroll(_this7.currentPointerCoords.y);

          var aboveTable = _this7.scrollY > _this7.table.topY;
          var belowTable = _this7.scrollY + _this7.windowHeight < _this7.table.bottomY;

          if (scrollAmount > 0 && belowTable || scrollAmount < 0 && aboveTable) {
            window.scrollBy(0, scrollAmount);
          }
        }, this.scrollSettings.interval);
      }
    }, {
      key: "restripeTable",
      value: function restripeTable() {
        var _this8 = this;

        var draggableRows = this.table.querySelectorAll(':scope > tbody > tr.draggable, :scope > tr.draggable');
        draggableRows.forEach(function (row) {
          var i = 0;
          var previousSibling = row.previousElementSibling;

          while (previousSibling) {
            if (_this8.constructor.isVisible(previousSibling)) {
              i += 1;
            }

            previousSibling = previousSibling.previousElementSibling;
          }

          var isEven = i % 2 === 0;
          row.classList.toggle('even', isEven);
          row.classList.toggle('odd', !isEven);
        });
      }
    }, {
      key: "onDrag",
      value: function onDrag() {
        return null;
      }
    }, {
      key: "onDrop",
      value: function onDrop() {
        return null;
      }
    }, {
      key: "row",
      value: function row(tableRow, method, indentEnabled, maxDepth, addClasses) {
        var rowObject = {
          element: tableRow,
          method: method,
          group: [tableRow],
          groupDepth: tableRow.querySelectorAll('.js-indentation').length,
          changed: false,
          table: tableRow.closest('table'),
          indentEnabled: indentEnabled,
          maxDepth: maxDepth,
          direction: '',
          addClasses: addClasses,
          swap: this.swap,
          indent: this.indent,
          onSwap: this.onSwap,
          validIndentInterval: this.validIndentInterval,
          onIndent: this.onIndent,
          removeIndentClasses: this.removeIndentClasses,
          findSiblings: this.findSiblings,
          findChildren: this.findChildren,
          isValidSwap: this.isValidSwap,
          markChanged: this.markChanged
        };

        if (indentEnabled) {
          rowObject.indents = rowObject.groupDepth;
          rowObject.children = rowObject.findChildren();
          rowObject.group = [].concat(_toConsumableArray(rowObject.group), _toConsumableArray(rowObject.children));

          for (var n = 0; n < rowObject.group.length; n++) {
            var indentationLength = typeof rowObject.group[n] !== 'undefined' ? rowObject.group[n].querySelectorAll('.js-indentation').length : 0;
            rowObject.groupDepth = Math.max(indentationLength, rowObject.groupDepth);
          }
        }

        return rowObject;
      }
    }, {
      key: "findChildren",
      value: function findChildren() {
        var parentIndentation = this.indents;
        var currentRow = Drupal.TableDrag.next(this.element, 'tr.draggable');
        var rows = [];
        var child = 0;

        function rowIndentation(el, indentNum) {
          if (child === 1 && indentNum === parentIndentation) {
            el.classList.add('tree-child-first');
          }

          if (indentNum === parentIndentation) {
            el.classList.add('tree-child');
          } else if (indentNum > parentIndentation) {
            el.classList.add('tree-child-horizontal');
          }
        }

        while (currentRow) {
          if (currentRow.querySelectorAll('.js-indentation').length > parentIndentation) {
            child += 1;
            rows.push(currentRow);

            if (this.addClasses) {
              currentRow.querySelectorAll('.js-indentation').forEach(rowIndentation);
            }
          } else {
            break;
          }

          currentRow = Drupal.TableDrag.next(currentRow, 'tr.draggable');
        }

        if (this.addClasses && rows.length) {
          rows[rows.length - 1].querySelector(".js-indentation:nth-child(".concat(parentIndentation + 1, ")")).classList.add('tree-child-last');
        }

        return rows;
      }
    }, {
      key: "isValidSwap",
      value: function isValidSwap(row) {
        if (this.indentEnabled) {
          var prevRow;
          var nextRow;

          if (this.direction === 'down') {
            prevRow = row;
            nextRow = Drupal.TableDrag.next(row, 'tr');
          } else {
            prevRow = Drupal.TableDrag.previous(row, 'tr');
            nextRow = row;
          }

          this.interval = this.validIndentInterval(prevRow, nextRow);

          if (this.interval.min > this.interval.max) {
            return false;
          }
        }

        if (!row.matches('.draggable') && this.table.tBodies[0].rows[0] === row) {
          return false;
        }

        return true;
      }
    }, {
      key: "swap",
      value: function swap(position, row) {
        var _this9 = this;

        this.group.forEach(function (rowInGroup) {
          Drupal.detachBehaviors(rowInGroup, drupalSettings, 'move');
        });
        row.insertAdjacentElement(position, this.group[0]);
        this.group.forEach(function (rowInGroup, index) {
          if (index !== 0) {
            _this9.group[index - 1].insertAdjacentElement('afterend', rowInGroup);
          }

          Drupal.attachBehaviors(rowInGroup, drupalSettings);
        });
        this.changed = true;
        this.onSwap(row);
      }
    }, {
      key: "validIndentInterval",
      value: function validIndentInterval(prevRow, nextRow) {
        var maxIndent;
        var minIndent = nextRow ? nextRow.querySelectorAll('.js-indentation').length : 0;

        if (!prevRow || !prevRow.matches('.draggable') || this.element.matches('.tabledrag-root')) {
          maxIndent = 0;
        } else {
          maxIndent = prevRow.querySelectorAll('.js-indentation').length + (prevRow.matches('.tabledrag-leaf') ? 0 : 1);

          if (this.maxDepth) {
            maxIndent = Math.min(maxIndent, this.maxDepth - (this.groupDepth - this.indents));
          }
        }

        return {
          min: minIndent,
          max: maxIndent
        };
      }
    }, {
      key: "indent",
      value: function indent(indentDiff) {
        var _this10 = this;

        if (!this.interval) {
          var prevRow = Drupal.TableDrag.previous(this.element, 'tr');
          var nextRow = Drupal.TableDrag.next(this.group[this.group.length - 1], 'tr');
          this.interval = this.validIndentInterval(prevRow, nextRow);
        }

        var indent = this.indents + indentDiff;
        indent = Math.max(indent, this.interval.min);
        indent = Math.min(indent, this.interval.max);
        indentDiff = indent - this.indents;

        for (var n = 1; n <= Math.abs(indentDiff); n++) {
          if (indentDiff < 0) {
            this.group.forEach(function (groupRow) {
              var firstIndent = groupRow.querySelector('.js-indentation:first-of-type');
              firstIndent.parentNode.removeChild(firstIndent);
            });
            this.indents -= 1;
          } else {
            (function () {
              var newIndent = Drupal.TableDrag.stringToElement(Drupal.theme('tableDragIndentation'));

              _this10.group.forEach(function (groupRow) {
                var cellWithIndents = groupRow.querySelector('td:first-of-type');
                cellWithIndents.insertBefore(newIndent.cloneNode(true), cellWithIndents.firstChild);
              });

              _this10.indents += 1;
            })();
          }
        }

        if (indentDiff) {
          this.changed = true;
          this.groupDepth += indentDiff;
          this.onIndent();
        }

        return indentDiff;
      }
    }, {
      key: "findSiblings",
      value: function findSiblings(rowSettings) {
        var siblings = [];
        var directions = ['previousElementSibling', 'nextElementSibling'];
        var rowIndentation = this.indents;
        var checkRowIndentation;

        for (var d = 0; d < directions.length; d++) {
          var checkRow = this.element[directions[d]];

          while (checkRow) {
            if (checkRow.querySelector(".".concat(rowSettings.target))) {
              if (this.indentEnabled) {
                checkRowIndentation = checkRow.querySelectorAll('.js-indentation').length;
              }

              if (!this.indentEnabled || checkRowIndentation === rowIndentation) {
                siblings.push(checkRow);
              } else if (checkRowIndentation < rowIndentation) {
                break;
              }
            } else {
              break;
            }

            checkRow = checkRow[directions[d]];
          }

          if (directions[d] === 'previousElementSibling') {
            siblings.reverse();
            siblings.push(this.element);
          }
        }

        return siblings;
      }
    }, {
      key: "removeIndentClasses",
      value: function removeIndentClasses() {
        var _this11 = this;

        Object.keys(this.children || {}).forEach(function (n) {
          if (typeof _this11.children[n] !== 'undefined') {
            _this11.children[n].querySelectorAll('.js-indentation').forEach(function (indentation) {
              indentation.classList.remove('tree-child', 'tree-child-first', 'tree-child-last', 'tree-child-horizontal');
            });
          }
        });
      }
    }, {
      key: "markChanged",
      value: function markChanged() {
        var marker = Drupal.TableDrag.stringToElement(Drupal.theme('tableDragChangedMarker'));
        var cell = this.element.querySelector('td:first-of-type');

        if (cell.querySelectorAll('abbr.tabledrag-changed').length === 0) {
          cell.append(marker);
        }
      }
    }, {
      key: "onIndent",
      value: function onIndent() {
        return null;
      }
    }, {
      key: "onSwap",
      value: function onSwap(swappedRow) {
        return null;
      }
    }], [{
      key: "stringToElement",
      value: function stringToElement(string) {
        var parser = new DOMParser();
        var elementContainer = parser.parseFromString(string, 'text/html');
        return elementContainer.body.firstChild;
      }
    }, {
      key: "previous",
      value: function previous(element, selector) {
        var sibling = element.previousElementSibling;

        if (!selector) {
          return sibling;
        }

        while (sibling) {
          if (sibling.matches(selector)) {
            return sibling;
          }

          sibling = sibling.previousElementSibling;
        }
      }
    }, {
      key: "next",
      value: function next(element, selector) {
        var sibling = element.nextElementSibling;

        if (!selector) {
          return sibling;
        }

        while (sibling) {
          if (sibling.matches(selector)) {
            return sibling;
          }

          sibling = sibling.nextElementSibling;
        }
      }
    }, {
      key: "prevAll",
      value: function prevAll(element, selector) {
        var prevElement = element.previousElementSibling;
        var result = [];

        while (prevElement) {
          if (selector === null || prevElement.matches(selector)) {
            result.push(prevElement);
          }

          prevElement = prevElement.previousElementSibling;
        }

        return result;
      }
    }, {
      key: "isHidden",
      value: function isHidden(element) {
        if (!element) {
          return false;
        }

        do {
          if (element instanceof Element) {
            var style = window.getComputedStyle(element);

            if (style.width === '0' || style.height === '0' || style.opacity === '0' || style.display === 'none' || style.visibility === 'hidden' || element.hidden) {
              return true;
            }
          }

          element = element.parentNode;
        } while (element);

        return false;
      }
    }, {
      key: "isVisible",
      value: function isVisible(element) {
        return !!(element.offsetWidth || element.offsetHeight || element.getClientRects().length);
      }
    }, {
      key: "addColspanClass",
      value: function addColspanClass(row, columnIndex) {
        var index = columnIndex;
        var cells = row.children;
        Array.from(cells).forEach(function (tableCell, cellIndex) {
          if (cellIndex < index && tableCell.colSpan && tableCell.colSpan > 1) {
            index -= tableCell.colSpan - 1;
          }
        });

        if (index > 0) {
          var cell = cells[index - 1];

          if (cell) {
            if (cell.colSpan > 1) {
              cell.classList.add('tabledrag-has-colspan');
            } else {
              cell.classList.add('tabledrag-hide');
            }
          }
        }
      }
    }, {
      key: "hideColumns",
      value: function hideColumns() {
        document.querySelectorAll('[data-drupal-tabledrag-table]').forEach(function (table) {
          table.querySelectorAll('.tabledrag-hide').forEach(function (tabledragHide) {
            tabledragHide.style.display = 'none';
          });
          table.querySelectorAll('.tabledrag-handle').forEach(function (tabledragHandle) {
            tabledragHandle.style.display = '';
          });
          table.querySelectorAll('.tabledrag-has-colspan').forEach(function (tabledragHasColspan) {
            var colspan = tabledragHasColspan.getAttribute('colspan');
            tabledragHasColspan.setAttribute('colspan', colspan - 1);
          });
        });
      }
    }, {
      key: "showColumns",
      value: function showColumns() {
        document.querySelectorAll('[data-drupal-tabledrag-table]').forEach(function (table) {
          table.querySelectorAll('.tabledrag-hide').forEach(function (tabledragHide) {
            tabledragHide.style.display = '';
          });
          table.querySelectorAll('.tabledrag-handle').forEach(function (tabledragHandle) {
            tabledragHandle.style.display = 'none';
          });
          table.querySelectorAll('.tabledrag-has-colspan').forEach(function (tabledragHasColspan) {
            var colspan = tabledragHasColspan.getAttribute('colspan');
            tabledragHasColspan.setAttribute('colspan', colspan + 1);
          });
        });
      }
    }, {
      key: "pointerCoords",
      value: function pointerCoords(event) {
        if (event.pageX || event.pageY) {
          return {
            x: event.pageX,
            y: event.pageY
          };
        }

        return {
          x: event.clientX + document.body.scrollLeft - document.body.clientLeft,
          y: event.clientY + document.body.scrollTop - document.body.clientTop
        };
      }
    }, {
      key: "copyDragClasses",
      value: function copyDragClasses(sourceRow, targetRow, group) {
        var sourceElement = sourceRow ? sourceRow.querySelector(".".concat(group)) : null;
        var targetElement = targetRow ? targetRow.querySelector(".".concat(group)) : null;

        if (sourceElement && targetElement) {
          targetElement.className = sourceElement.className;
        }
      }
    }]);

    return _class;
  }();

  Drupal.TableDrag.instances = [];

  Drupal.theme.tableDragChangedMarker = function () {
    return "<abbr class=\"warning tabledrag-changed\" title=\"".concat(Drupal.t('Changed'), "\">*</abbr>");
  };

  Drupal.theme.tableDragIndentation = function () {
    return '<div class="js-indentation indentation">&nbsp;</div>';
  };

  Drupal.theme.tableDragChangedWarning = function () {
    return "<div class=\"tabledrag-changed-warning messages messages--warning\" role=\"alert\">".concat(Drupal.theme('tableDragChangedMarker'), " ").concat(Drupal.t('You have unsaved changes.'), "</div>");
  };

  Drupal.theme.tableDragToggle = function () {
    return "<div class=\"tabledrag-toggle-weight-wrapper\" data-drupal-selector=\"tabledrag-toggle-weight-wrapper\">\n            <button type=\"button\" class=\"link tabledrag-toggle-weight\" data-drupal-selector=\"tabledrag-toggle-weight\"></button>\n            </div>";
  };

  Drupal.theme.toggleButtonContent = function (show) {
    return show ? Drupal.t('Hide row weights') : Drupal.t('Show row weights');
  };

  Drupal.theme.tableDragHandle = function () {
    return "<a href=\"#\" title=\"".concat(Drupal.t('Drag to re-order'), "\"\n        class=\"tabledrag-handle\"><div class=\"handle\">&nbsp;</div></a>");
  };
})(jQuery, Drupal, drupalSettings);